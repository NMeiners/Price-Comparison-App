<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Local Price Finder</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  :root{
    --bg:#0b1220; --panel:#07121a; --card:#0f1724; --muted:#9fb0c0; --accent:#22d3ee; --text:#e6f6fb;
    --light-bg:#f6f8fb; --light-panel:#ffffff; --light-text:#111827; --light-muted:#556170; --light-accent:#2563eb;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
  body.light { background:var(--light-bg); color:var(--light-text); }
  body.light .topbar, body.light .searchbar { background:linear-gradient(90deg,#fff,#f5f7fb); color:var(--light-text) }
  .app{max-width:1200px;margin:12px auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  .topbar{display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;background:linear-gradient(90deg,#06202a,#04202b);box-shadow:0 8px 24px rgba(2,6,23,0.6)}
  body.light .topbar{background:linear-gradient(90deg,#fff,#f7fbff);box-shadow:none}
  .brand{font-weight:700;font-size:18px}
  .sub{font-size:13px;color:var(--muted)}
  .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .iconBtn{background:transparent;border:0;color:inherit;cursor:pointer;font-size:16px;padding:8px;border-radius:8px}
  .searchbar{display:flex;gap:8px;padding:10px;border-radius:10px;background:var(--panel);align-items:center;flex-wrap:wrap}
  .searchbar input[type="search"]{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:15px;outline:none}
  .btn{background:var(--accent);border:0;padding:10px 12px;border-radius:8px;color:#042;font-weight:700;cursor:pointer}
  body.light .btn{background:var(--light-accent); color:#fff}
  .layout{display:grid;grid-template-columns:380px 1fr;gap:12px;min-height:60vh}
  @media(max-width:900px){ .layout{grid-template-columns:1fr;grid-auto-rows:min-content} }
  .panel{background:var(--card);padding:12px;border-radius:12px;overflow:auto}
  body.light .panel{background:var(--light-panel)}
  #results{display:flex;flex-direction:column;gap:8px}
  .storeCard{padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);display:flex;gap:10px;align-items:flex-start;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .storeCard h4{margin:0;font-size:15px}
  .meta{font-size:13px;color:var(--muted);margin-top:4px}
  .actions{margin-left:auto;display:flex;flex-direction:column;gap:8px}
  .linkBtn{display:inline-block;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--accent);text-decoration:none;font-weight:700;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  #map {height:72vh;border-radius:12px;overflow:hidden}
  .status{font-size:13px;color:var(--muted);margin-top:6px}
  .settingsModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:9999}
  .settingsCard{width:320px;background:var(--card);padding:14px;border-radius:10px}
  body.light .settingsCard{background:var(--light-panel)}
  .row{display:flex;gap:8px;align-items:center}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  select,input[type="range"]{width:100%}
  .divider{height:1px;background:rgba(255,255,255,0.03);margin:8px 0}
  .storeCard.active{outline:2px solid rgba(34,211,238,0.12);background:linear-gradient(90deg,rgba(34,211,238,0.03),transparent)}
  .price{font-weight:800;color:var(--accent);margin-top:6px}
  body.light .price{color:var(--light-accent)}
  footer.note{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div>
      <div class="brand">Local Price Finder</div>
      <div class="sub">Find items near you in local stores. Client-only. No keys required.</div>
    </div>
    <div class="controls">
      <div class="small" id="unitLabel">units: km</div>
      <button class="iconBtn" id="settingsBtn" title="Settings">⚙️</button>
    </div>
  </div>

  <div class="searchbar panel">
    <input id="itemInput" type="search" placeholder="Search items (e.g., milk, batteries, bread)" autocomplete="off" />
    <button id="searchBtn" class="btn">Search</button>
    <div style="width:12px"></div>
    <div class="small">Radius:
      <input id="radiusRange" type="range" min="500" max="20000" step="250" value="3000" style="vertical-align:middle">
      <span id="radiusLabel">3.0 km</span>
    </div>
  </div>

  <div class="layout">
    <div class="panel" id="leftPanel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div class="small" id="resultsHeader">Results</div>
        <div class="small" id="statusText">Ready</div>
      </div>

      <div id="results"></div>

      <div class="divider"></div>
      <div class="small">Results come from OpenStreetMap via Overpass and Nominatim. Fuzzy matching is used to find likely matches.</div>
    </div>

    <div class="panel" id="mapPanel">
      <div id="map"></div>
    </div>
  </div>
</div>

<!-- Settings modal -->
<div id="settingsModal" class="settingsModal" aria-hidden="true">
  <div class="settingsCard">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <label>Units</label>
    <select id="unitSelect">
      <option value="km">Kilometers</option>
      <option value="mi">Miles</option>
    </select>

    <label style="margin-top:10px">Theme</label>
    <select id="themeSelect">
      <option value="dark">Dark</option>
      <option value="light">Light</option>
    </select>

    <label style="margin-top:10px">Max shop radius (meters)</label>
    <input id="radiusNumber" type="number" min="500" max="20000" step="100" value="3000">

    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
      <button id="closeSettings" class="btn" style="background:rgba(255,255,255,0.06);color:var(--text)">Close</button>
      <button id="saveSettings" class="btn">Save</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/*
  Clean, self-contained index.html implementing:
  - Overpass primary fetch for local shops
  - Nominatim fallback
  - Fuzzy matching (local Levenshtein + token overlap scoring)
  - Map markers + results list (click sync)
  - Settings modal (units, theme, radius)
  - Enter key triggers search
  - Graceful fallbacks and errors
*/

// ------------------- App state -------------------
const state = {
  pos: null,
  map: null,
  markers: [],
  stores: [],
  radius: 3000,
  unit: 'km'
};

// ------------------- DOM -------------------
const itemInput = document.getElementById('itemInput');
const searchBtn = document.getElementById('searchBtn');
const radiusRange = document.getElementById('radiusRange');
const radiusLabel = document.getElementById('radiusLabel');
const resultsEl = document.getElementById('results');
const statusText = document.getElementById('statusText');
const unitLabel = document.getElementById('unitLabel');
const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const unitSelect = document.getElementById('unitSelect');
const themeSelect = document.getElementById('themeSelect');
const radiusNumber = document.getElementById('radiusNumber');
const closeSettings = document.getElementById('closeSettings');
const saveSettings = document.getElementById('saveSettings');

// ------------------- Utils -------------------
function setStatus(msg){ statusText.textContent = msg; }
function formatRadius(m){ return state.unit==='mi' ? (m/1609.344).toFixed(1)+' mi' : (m/1000).toFixed(1)+' km'; }
function formatDistanceMeters(m){ return state.unit==='mi' ? (m/1609.344).toFixed(1)+' mi' : (m/1000).toFixed(2)+' km'; }
function kmToMeters(km){ return Math.round(km*1000); }

// Levenshtein distance (iterative, memory-efficient)
function levenshtein(a,b){
  if(a===b) return 0;
  if(a.length===0) return b.length;
  if(b.length===0) return a.length;
  a = a.toLowerCase(); b = b.toLowerCase();
  const v0 = new Array(b.length+1).fill(0);
  const v1 = new Array(b.length+1).fill(0);
  for(let j=0;j<=b.length;j++) v0[j]=j;
  for(let i=0;i<a.length;i++){
    v1[0]=i+1;
    for(let j=0;j<b.length;j++){
      const cost = a[i]===b[j] ? 0 : 1;
      v1[j+1] = Math.min(v1[j]+1, v0[j+1]+1, v0[j]+cost);
    }
    for(let j=0;j<=b.length;j++) v0[j]=v1[j];
  }
  return v1[b.length];
}

// normalized similarity 0..1 (1 = identical)
function similarity(a,b){
  if(!a && !b) return 1;
  if(!a || !b) return 0;
  const d = levenshtein(a,b);
  const maxLen = Math.max(a.length, b.length);
  return 1 - (d / maxLen);
}

// token overlap score: fraction of tokens found in hay
function tokenOverlapScore(hay, tokens){
  if(!tokens.length) return 0;
  let matched=0;
  for(const t of tokens){
    if(hay.includes(t)) matched++;
  }
  return matched / tokens.length;
}

// compute a combined fuzzy score between 0 and 1
function computeFuzzyScore(store, queryTokens, rawQuery){
  // build haystack from multiple tags and address
  const tags = store.tags||{};
  const fields = [
    tags.name || '',
    tags.shop || '',
    tags.amenity || '',
    tags.brand || '',
    tags.product || '',
    store.addr || ''
  ].join(' ').toLowerCase();

  // token overlap
  const tokenScore = tokenOverlapScore(fields, queryTokens);

  // best similarity against full strings (name, brand, product)
  const candidates = [tags.name, tags.brand, tags.product, tags.shop].filter(Boolean);
  let bestSim = 0;
  for(const c of candidates){
    bestSim = Math.max(bestSim, similarity(String(c).toLowerCase(), rawQuery));
  }

  // distance penalty: if store has distanceMeters computed, apply small decay for distant stores
  const distMeters = store.distanceMeters || 0;
  const distPenalty = distMeters ? Math.min(1, distMeters / Math.max(20000, state.radius*2)) : 0; // 0..1

  // weighted sum: emphasize token coverage and string similarity
  const score = (0.55 * tokenScore) + (0.40 * bestSim) - (0.20 * distPenalty);
  // clamp to 0..1
  return Math.max(0, Math.min(1, score));
}

// haversine (meters)
function haversineMeters(a,b){
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const la = toRad(a.lat), lb = toRad(b.lat);
  const s = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2;
  return R * 2 * Math.asin(Math.sqrt(s));
}

// escape for HTML
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// ------------------- Map -------------------
function initMap(){
  state.map = L.map('map').setView([39.5,-98.35],4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OpenStreetMap contributors' }).addTo(state.map);

  // try geolocation and show user
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(p=>{
      state.pos = { lat: p.coords.latitude, lon: p.coords.longitude };
      L.circleMarker([state.pos.lat, state.pos.lon], { radius:7, color:'#22d3ee', fill:true, fillColor:'#22d3ee' }).addTo(state.map)
        .bindPopup('You are here');
      state.map.setView([state.pos.lat, state.pos.lon], 13);
    }, (err)=>{
      console.warn('geo fail', err);
      setStatus('Location unavailable. Allow location for best results.');
    }, { enableHighAccuracy:true, timeout:10000 });
  } else {
    setStatus('Geolocation not supported.');
  }
}
initMap();

// ------------------- UI wiring -------------------
radiusRange.value = state.radius;
radiusNumber.value = state.radius;
radiusLabel.textContent = formatRadius(state.radius);

function wireUi(){
  searchBtn.addEventListener('click', onSearch);
  itemInput.addEventListener('keydown', e => { if(e.key === 'Enter') onSearch(); });

  radiusRange.addEventListener('input', ()=> {
    state.radius = Number(radiusRange.value);
    radiusNumber.value = state.radius;
    radiusLabel.textContent = formatRadius(state.radius);
  });
  radiusNumber.addEventListener('change', ()=> {
    state.radius = Number(radiusNumber.value || state.radius);
    radiusRange.value = state.radius;
    radiusLabel.textContent = formatRadius(state.radius);
  });

  settingsBtn.addEventListener('click', ()=> { settingsModal.style.display = 'flex'; settingsModal.setAttribute('aria-hidden','false'); });
  closeSettings.addEventListener('click', ()=> closeSettingsModal());
  saveSettings.addEventListener('click', ()=> { applySettings(); closeSettingsModal(); });

  unitSelect.addEventListener('change', ()=> {
    state.unit = unitSelect.value;
    unitLabel.textContent = 'units: ' + state.unit;
    refreshDistancesUI();
  });
  themeSelect.addEventListener('change', ()=> document.body.classList.toggle('light', themeSelect.value === 'light'));
  settingsModal.addEventListener('click', e => { if(e.target === settingsModal) closeSettingsModal(); });
}
wireUi();

function closeSettingsModal(){ settingsModal.style.display='none'; settingsModal.setAttribute('aria-hidden','true'); }
function applySettings(){
  state.radius = Number(radiusNumber.value || state.radius);
  radiusRange.value = state.radius;
  radiusLabel.textContent = formatRadius(state.radius);
  unitLabel.textContent = 'units: ' + state.unit;
  refreshDistancesUI();
}

// ------------------- Overpass + Nominatim fetch helpers -------------------
async function overpassNearby(lat, lon, radius){
  // fetch shops & common retail amenities within radius
  const q = `[out:json][timeout:25];
    (
      node(around:${radius},${lat},${lon})[shop];
      way(around:${radius},${lat},${lon})[shop];
      relation(around:${radius},${lat},${lon})[shop];
      node(around:${radius},${lat},${lon})[amenity=supermarket];
      way(around:${radius},${lat},${lon})[amenity=supermarket];
      relation(around:${radius},${lat},${lon})[amenity=supermarket];
    );
    out center tags;`;
  try{
    const resp = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', body: q });
    if(!resp.ok) throw new Error('Overpass failed: ' + resp.status);
    const j = await resp.json();
    return j.elements.map(e=>{
      const center = e.type === 'node' ? { lat: e.lat, lon: e.lon } : (e.center || { lat: e.lat, lon: e.lon });
      const addr = (e.tags && (e.tags['addr:street'] || e.tags['addr:housenumber'])) || '';
      return { id: e.id, type: e.type, name: (e.tags && (e.tags.name || e.tags.brand)) || 'Unnamed', tags: e.tags || {}, lat: center.lat, lon: center.lon, addr };
    });
  }catch(err){
    console.warn('overpass error', err);
    return [];
  }
}

async function overpassNearbyBroad(lat, lon, radius){
  const q = `[out:json][timeout:25];
    (
      node(around:${radius},${lat},${lon});
      way(around:${radius},${lat},${lon});
      relation(around:${radius},${lat},${lon});
    );
    out center tags;`;
  try{
    const resp = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', body: q });
    if(!resp.ok) throw new Error('Overpass broad failed: ' + resp.status);
    const j = await resp.json();
    return j.elements.map(e=>{
      const center = e.type === 'node' ? { lat: e.lat, lon: e.lon } : (e.center || { lat: e.lat, lon: e.lon });
      return { id: e.id, type: e.type, name: (e.tags && (e.tags.name || e.tags.brand)) || 'Unnamed', tags: e.tags || {}, lat: center.lat, lon: center.lon, addr: '' };
    });
  }catch(err){
    console.warn('overpass broad error', err);
    return [];
  }
}

async function nominatimFallback(query, lat, lon, radius){
  try{
    const q = encodeURIComponent(query + ' near ' + lat + ',' + lon);
    const url = `https://nominatim.openstreetmap.org/search.php?q=${q}&format=jsonv2&limit=20`;
    const resp = await fetch(url);
    if(!resp.ok) return [];
    const j = await resp.json();
    return j.map((p, idx)=>({
      id: 'n_' + idx,
      name: p.display_name.split(',')[0] || query,
      tags: {},
      lat: Number(p.lat),
      lon: Number(p.lon),
      addr: p.display_name
    }));
  }catch(err){
    console.warn('nominatim err', err);
    return [];
  }
}

// ------------------- Filtering & ranking (fuzzy) -------------------
function scoreAndFilterStores(stores, query){
  const raw = query.trim().toLowerCase();
  const tokens = raw.split(/\s+/).filter(Boolean);
  // compute distances if pos available
  if(state.pos){
    stores.forEach(s => {
      if(!s.distanceMeters) s.distanceMeters = haversineMeters({ lat: state.pos.lat, lon: state.pos.lon }, { lat: s.lat, lon: s.lon });
    });
  }
  // score
  const scored = stores.map(s => {
    const score = computeFuzzyScore(s, tokens, raw);
    return { store: s, score };
  });
  // keep those with score >= threshold OR take top N if none meet threshold
  const THRESH = 0.25; // conservative threshold
  const filtered = scored.filter(x => x.score >= THRESH).sort((a,b) => b.score - a.score);
  if(filtered.length > 0) return filtered.map(x => ({ ...x.store, _score: x.score }));
  // if no items meet threshold, return top 12 by score (best-effort)
  scored.sort((a,b) => b.score - a.score);
  return scored.slice(0,12).map(x => ({ ...x.store, _score: x.score }));
}

// ------------------- Render / UI -------------------
function clearResultsUI(){
  resultsEl.innerHTML = '';
  state.markers.forEach(m => { try{ state.map.removeLayer(m); }catch(e){} });
  state.markers = [];
  state.stores = [];
}

function renderStoreCard(store, idx){
  const div = document.createElement('div');
  div.className = 'storeCard';
  div.dataset.idx = idx;
  const name = escapeHtml(store.name || (store.tags && (store.tags.name || store.tags.shop)) || 'Store');
  const meta = escapeHtml((store.tags && (store.tags.shop || store.tags.amenity)) || '') + (store.addr ? ' • ' + escapeHtml(store.addr) : '');
  const dist = store.distanceMeters ? formatDistanceMeters(store.distanceMeters) : '';
  const scoreText = store._score !== undefined ? ` • ${Math.round(store._score * 100)}%` : '';
  div.innerHTML = `<div style="flex:1">
    <h4>${name}</h4>
    <div class="meta">${meta}</div>
    <div class="small">${dist}${scoreText}</div>
  </div>
  <div class="actions">
    <a class="linkBtn" href="https://www.openstreetmap.org/${store.type}/${store.id}" target="_blank" rel="noopener">OSM</a>
  </div>`;
  div.addEventListener('click', () => {
    const lat = store.lat, lon = store.lon;
    if(lat && lon){
      state.map.setView([lat, lon], 16);
      // open associated marker popup
      const m = state.markers[idx];
      if(m && m.openPopup) m.openPopup();
    }
    // highlight UI
    document.querySelectorAll('.storeCard.active').forEach(e=>e.classList.remove('active'));
    div.classList.add('active');
  });
  resultsEl.appendChild(div);

  // add marker
  if(store.lat && store.lon){
    const marker = L.marker([store.lat, store.lon]).addTo(state.map).bindPopup(name);
    state.markers.push(marker);
    marker.on('click', () => {
      document.querySelectorAll('.storeCard.active').forEach(e=>e.classList.remove('active'));
      div.classList.add('active');
    });
  } else {
    state.markers.push(null);
  }
}

function renderResults(stores){
  clearResultsUI();
  if(!stores || stores.length === 0){
    setStatus('No matches found.');
    return;
  }
  // attempt to fit map to markers
  const bounds = [];
  stores.forEach((s, i) => {
    renderStoreCard(s, i);
    if(s.lat && s.lon) bounds.push([s.lat, s.lon]);
  });
  if(bounds.length){
    try{
      state.map.fitBounds(bounds, { padding: [40,40], maxZoom: 16 });
    }catch(e){}
  }
  state.stores = stores;
  setStatus(`Showing ${stores.length} result(s).`);
}

function refreshDistancesUI(){
  if(!state.stores || !state.stores.length) return;
  state.stores.forEach(s=>{
    if(state.pos) s.distanceMeters = haversineMeters({ lat: state.pos.lat, lon: state.pos.lon }, { lat: s.lat, lon: s.lon });
  });
  renderResults(state.stores);
}

// ------------------- Main search flow -------------------
async function onSearch(){
  clearResultsUI();
  const rawQuery = (itemInput.value || '').trim();
  if(!rawQuery){
    setStatus('Enter a search term.');
    return;
  }
  setStatus('Searching...');
  // ensure location
  if(!state.pos){
    try{
      await getLocationOnce();
    }catch(e){
      setStatus('Location required.');
      return;
    }
  }

  // Step 1: Overpass near shops
  const primary = await overpassNearby(state.pos.lat, state.pos.lon, state.radius);
  setStatus(`Fetched ${primary.length} nearby places. Scoring...`);

  // Step 2: Score & filter with fuzzy
  // compute distances first for scoring
  primary.forEach(s => {
    if(state.pos) s.distanceMeters = s.distanceMeters || haversineMeters({ lat: state.pos.lat, lon: state.pos.lon }, { lat: s.lat, lon: s.lon });
  });

  let matched = scoreAndFilterStores(primary, rawQuery);

  // Step 3: If no good matches, try Nominatim fallback and broadened Overpass
  if(!matched || matched.length === 0){
    setStatus('No close matches. Trying Nominatim fallback...');
    const nom = await nominatimFallback(rawQuery, state.pos.lat, state.pos.lon, state.radius);
    matched = scoreAndFilterStores(nom, rawQuery);
  }

  if(!matched || matched.length === 0){
    setStatus('No direct matches. Fetching broader set and returning nearest by proximity...');
    const broad = await overpassNearbyBroad(state.pos.lat, state.pos.lon, Math.min(state.radius * 2, 20000));
    // if still nothing: pick nearest 15
    if(broad.length === 0){
      setStatus('No places found nearby.');
      return;
    }
    // compute distances and pick nearest
    broad.forEach(s => { if(state.pos) s.distanceMeters = haversineMeters({ lat: state.pos.lat, lon: state.pos.lon }, { lat: s.lat, lon: s.lon }); });
    broad.sort((a,b)=> (a.distanceMeters||0) - (b.distanceMeters||0));
    matched = broad.slice(0,15);
  }

  // Finalize: ensure distance & score present
  matched.forEach((s, idx) => {
    if(state.pos && !s.distanceMeters) s.distanceMeters = haversineMeters({ lat: state.pos.lat, lon: state.pos.lon }, { lat: s.lat, lon: s.lon });
    if(s._score === undefined) s._score = 0;
  });

  // Sort by score desc, then distance asc
  matched.sort((a,b) => (b._score - a._score) || ((a.distanceMeters||0) - (b.distanceMeters||0)));

  // Render top results (limit to 50)
  renderResults(matched.slice(0,50));
}

// ------------------- Geolocation helper -------------------
function getLocationOnce(){
  return new Promise((res,reject)=>{
    if(state.pos) return res(state.pos);
    if(!navigator.geolocation) return reject(new Error('no geo'));
    navigator.geolocation.getCurrentPosition(p=>{
      state.pos = { lat: p.coords.latitude, lon: p.coords.longitude };
      // add user marker
      L.circleMarker([state.pos.lat, state.pos.lon], { radius:7, color:'#22d3ee', fill:true, fillColor:'#22d3ee' }).addTo(state.map).bindPopup('You are here');
      state.map.setView([state.pos.lat, state.pos.lon], 13);
      res(state.pos);
    }, err => reject(err), { enableHighAccuracy:true, timeout:10000 });
  });
}

// ------------------- Initial UI -------------------
setStatus('Ready. Allow location and search for items.');
radiusLabel.textContent = formatRadius(state.radius);

// ------------------- End of script -------------------
</script>
<footer class="note">Local Price Finder • Client-only • Data from OpenStreetMap (Overpass, Nominatim)</footer>
</body>
</html>
